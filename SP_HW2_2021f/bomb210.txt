There are rumors on the internets.
1 2 4 8 16 32
1 a 231
11 18
mfcdhg
5 1 3 4 2 6

<phase_2>
+25 -> read_six_numbers, scanf로 6개 숫자를 받음
+30 -> 첫 번째 숫자가 1인지 확인
***+34 -> jne로 1이 아니라면 +45로 점프
+36 -> rbx에 첫 번째 숫자 주소 저장
+39 -> rbp에 마지막 숫자 주소 저장
+43 -> +61로 점프
+61 -> eax에 첫 번째 숫자인 1 저장
+63 -> eax 두배
+65 -> 두 번째 숫자와 eax를 비교
+68 -> je로 같다면 +52로 점프한 후 모든 숫자 읽을 때까지 +52~+68반복

<phase_3>
+42 -> scanf로 한 줄을 받는다.
+47 -> scanf의 반환값인 인자의 개수와 2를 비교
***+50 -> jle로 2 <= 인자의 개수이면 
+52 -> 7과 scanf로 받은 첫 번째 수를 비교
***+57 -> 7 > 0x10(%rsp)(첫 번째 입력값)이면 +331으로 점프(첫 번째 수 <= 7이어야 한다.)
+129 -> 0xe7과 0x14(%rsp)(세 번째 입력값)이 같으면 +341로 점프(같지 않으면 explode_bomb)
+341 -> %al과 0xf(%rsp)(두 번째 입력값)를 비교, %al을 출력해보면 97이 나온다. 이에 맞는  char인 a가 입력이어야 한다.

<phase_4>
+35 -> scanf로 $rsp와 $rsp+0x4에 int 두개를 입력
+40 -> 입력받은 숫자의 수와 2를 비교
***+43 -> 같지 않다면 explode_bomb
+49 -> 0xe와 $rsp(첫 번째 숫자)를 비교
+56, +61, +66 -> $edx에 0xe, $esi에 0x0, $edi에 $rsp대입
+69 -> func4 호출
____________________fucn4시작
+1 -> $eax에 $edx(==14) 대입 -> 14
+3 -> $eax에 $esi(==0) 뺄셈 -> 0
+5 -> $ebx에 $eax 대입 -> eax = 14, ebx = 14
+7 -> $ebx를 오른쪽으로 0x1f만큼 shift -> eax = 14, ebx = 0
+10 -> $ebx에 $eax를 더함 -> eax = 14, ebx = 14
+12 -> $ebx를 오른쪽으로 1비트 shift -> eax = 14, ebx = 7
+14 -> $ebx에 $esi를 더함 -> eax = 14, ebx = 7
+16 -> $edi와 $ebx를 비교해서 $edi가 $ebx보다 작으면 +28로 점프
+20 -> $edi가 $ebx를 비교해서 $edi가 $ebx보다 크면 +40으로 점프
+24 -> 둘 다 아니라면 $eax에 $ebx를 대입한 후 return
코드로 나타내면 아래와 같다. (확인해본 결과, 정확하지 않다.)
int func4(int di, int si, int dx) {
    int ax = dx;
    ax -= si;
    int bx = ax;
    bx >>= 0x1f;
    bx += ax;
    bx >>= 1;
    bx += si;
    if (di < bx) {
        dx = bx - 1;
        bx += func4(di, si, dx);
    }
    else if (di > bx) {
        si = bx + 1;
        bx += func4(di, si, dx);
        bx += ax;
    }
    ax = bx;
    return ax;
}
____________________func4종료
***+74 -> 0x12와 func4의 반환값을 비교해서 다르면 explode bomb
+79 -> 0x12(18)와 0x4($rsp)(두 번째 숫자)를 비교해서 같으면 defuse

<phase_5>
+24 -> string_length를 호출, 입력받은 string의 길이를 반환 ($rbx에 string 저장)
***+29 -> string의 길이와 6을 비교해서 다르면 explode bomb
+46 ~ +69 -> loop 형성. (총 6회 반복, rax가 0~5일동안)
+46 -> rax번째 char을 그 아스키에 맞는 int로 바꿔 $edx에 저장
+50 -> 0xf와 $edx를 and연산하여 나온 하위 4비트를 취하여 $edx에 저장
+53 -> edx에 rcx + rdx + 1을 저장 (rcx는 maduiersnfotvbyl)
+57 -> edx의 하위 4비트를 $rsp + 0x1 + 1 * $rax에 저장($rsp + 0x1부터 한글자씩 저장)
+69 -> loop가 끝난 뒤 $rsp + 0x7에 널을 넣어줘서 문자열 치환 완료
+88 -> strings_not_equal에 $rdi로 바꾼 문자열을, $rsi로 정답 문자열 $rip+0x15cf(bruins)를 넣어줘 비교해서 같다면 defuse

m  a  d  u  i   e  r  s   n  f  o   t    v    b    y    l
0   1  2  3  4  5  6  7  8  9  10 11  12  13   14  15

bruins를 만들려면 하위 4비트가 13, 6, 3, 4, 8, 7이면 된다.
다 확인하는건 너무 비효율적이므로
int get4bit(char a, int target) {
    return ((int)a & 0xf) == target;
}

int main(void) {
    int target;
    scanf("%d", &target);
    for (char i = 'a'; i <= 'z'; i++) {
        if (get4bit(i, target))
            printf("%c, ", i);
    }
    return 0;
}
이 코드를 이용해서 쓴다.
13 -> m
6 -> f 또는 v
3 -> c 또는 s
4 -> d 또는 t
8 -> h 또는 x
7 -> g 또는 w
로 문자열을 구성해주면 된다. ex) mfcdhg

<phase_6>
+32 -> 6개의 숫자를 $rsp+0x0 ~ $rsp+0x14에 입력받는다.
+37 -> r13d에 0 대입
+43 -> +82로 점프
+82 -> 첫 번째 숫자를 $rbp에 대입
+85 -> 첫 번째 숫자를 $eax에 대입
+89 -> $eax에 1을 뺀 값이 5보다 크다면 explode bomb (첫 번째 숫자 <= 6)
+97 -> 0인 $r13d에 1씩 더하며 6이 되면 +160으로 점프
+107 -> $r13d를 $ebx에 대입 후 +60으로 점프
+60 -> $rax에 $ebx를 대입
+63 -> $eax에 $rax번째 숫자를 대입
***+66 -> $eax와 $rbp가 같다면 explode_bomb, 같지 않다면 +52로 점프해서 나머지 수들에 대해 중복여부 확인하는 loop
              모든 검사가 끝났다면 +78로 점프
+78 -> 점프 이후에는 나머지 수들에 대해서 값들이 6 이하인지와 중복여부를 검사
           6개의 수에 대해 모든 검사가 끝났다면 +160으로 점프
+160 -> $esi에 0을 대입
+165 -> +138로 점프
+138 -> $ecx에 $rsi번째 값을 대입
+141 -> $eax에 1을 대입
+146 -> $rdx에 노드 1
+153 -> $ecx가 1보다 크면 +112로 점프, 크지 않다면 +123으로 점프
이후는 잘 모르겠으나 노드 번호를 확인하여 5개를 내림차순으로 정렬하고, 6을 나머지 아무데나 넣어주면 된다.
